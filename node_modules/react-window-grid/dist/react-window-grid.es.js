import { __assign, __spreadArrays } from 'tslib';
import { useMemo, useRef, createElement, useState, useEffect, forwardRef, useImperativeHandle } from 'react';
import { css as css$1 } from 'emotion';
import anime from 'animejs';

var ItemPosition;

(function (ItemPosition) {
  ItemPosition["PRE"] = "pre";
  ItemPosition["MID"] = "mid";
  ItemPosition["POST"] = "post";
})(ItemPosition || (ItemPosition = {}));

function useMetadata(count, size, preCount, postCount) {
  return useMemo(function () {
    var _a;

    var getSize = typeof size === 'function' ? size : function () {
      return size;
    };

    var getPosition = function (itemIndex) {
      if (itemIndex < preCount) {
        return ItemPosition.PRE;
      } else if (itemIndex < count - postCount) {
        return ItemPosition.MID;
      }

      return ItemPosition.POST;
    };

    var meta = {};
    var offset = 0;
    var position;
    var startOffset = 0;
    var sizes = (_a = {}, _a[ItemPosition.PRE] = 0, _a[ItemPosition.MID] = 0, _a[ItemPosition.POST] = 0, _a);

    for (var itemIndex = 0; itemIndex < count; itemIndex += 1) {
      var size_1 = getSize(itemIndex);

      if (position !== getPosition(itemIndex)) {
        position = getPosition(itemIndex);
        startOffset = offset;
      }

      var localOffset = offset - startOffset;
      var offset_ = position === ItemPosition.POST ? localOffset : offset; // left: column.position === ItemPosition.POST ? column.localOffset : column.offset,
      // meta[itemIndex] = { size, offset: offset_, localOffset, position };

      meta[itemIndex] = {
        size: size_1,
        offset: offset_,
        localOffset: localOffset,
        offset_: offset
      };
      sizes[position] += size_1;
      offset += size_1;
    }

    return {
      meta: meta,
      pre: {
        count: preCount,
        size: sizes[ItemPosition.PRE],
        range: [0, preCount]
      },
      mid: {
        size: sizes[ItemPosition.MID],
        range: [preCount, count - postCount]
      },
      post: {
        count: postCount,
        size: sizes[ItemPosition.POST],
        range: [count - postCount, count]
      },
      total: {
        size: offset,
        count: count,
        range: [0, count]
      }
    };
  }, [count, size]);
}

function useMetadataFixed(metadata, clientSize, fillerType, minVisibleScrollViewWidth) {
  var totalSize = metadata.total.size;
  var preSize = metadata.pre.size;
  var postSize = metadata.post.size;
  var mass = useMemo(function () {
    var mass = clientSize - totalSize;

    if (mass < 0) {
      mass = -1;
    } // console.log(minVisibleScrollViewWidth);


    if (preSize + postSize + (minVisibleScrollViewWidth || 0) > clientSize) {
      mass = 0;
    }

    return mass;
  }, [clientSize, totalSize, preSize, postSize, minVisibleScrollViewWidth]); // mass = clientWidth -
  // console.log( clientWidth , metadata.total.size, metadata.pre.size, metadata.post.size);
  // // console.log(contentWidth, metadata.total.size)

  return useMemo(function () {
    var _a, _b;

    if (mass >= 0) {
      metadata = {
        meta: Object.keys(metadata.meta).reduce(function (accum, key) {
          var _a;

          var value = metadata.meta[key];

          var _value = __assign(__assign({}, value), {
            // @ts-ignore
            offset: value.offset_,
            // @ts-ignore
            localOffset: value.offset_
          });

          return __assign(__assign({}, accum), (_a = {}, _a[key] = _value, _a));
        }, {}),
        // @ts-ignore
        pre: {
          count: 0,
          size: 0,
          range: [0, 0]
        },
        // @ts-ignore
        mid: __assign({}, metadata.total),
        // @ts-ignore
        post: {
          count: 0,
          size: 0,
          range: [metadata.total.count, 0]
        },
        total: metadata.total
      };

      if (mass > 0) {
        if (fillerType === true || fillerType === 'append') {
          // // console.log(mass, metadata.total.size);
          var contentSize = metadata.total.size + mass;
          metadata = __assign(__assign({}, metadata), {
            // contentSize,
            meta: __assign(__assign({}, metadata.meta), (_a = {}, _a[metadata.total.count] = {
              size: mass,
              localOffset: metadata.total.size,
              offset: metadata.total.size,
              // @ts-ignore
              filler: true
            }, _a)),
            total: __assign(__assign({}, metadata.total), {
              count: metadata.total.count + 1,
              size: contentSize
            }),
            mid: __assign(__assign({}, metadata.total), {
              // @ts-ignore
              count: metadata.total.count + 1,
              range: [0, metadata.total.count + 1],
              size: contentSize
            })
          });
        } else if (fillerType === 'stretch') {
          var contentSize = metadata.total.size + mass;
          var lastKey = metadata.total.count - 1;
          metadata = __assign(__assign({}, metadata), {
            meta: __assign(__assign({}, metadata.meta), (_b = {}, _b[lastKey] = __assign(__assign({}, metadata.meta[lastKey]), {
              size: metadata.meta[lastKey].size + mass
            }), _b)),
            total: __assign(__assign({}, metadata.total), {
              size: contentSize
            }),
            // @ts-ignore
            mid: __assign(__assign({}, metadata.total), {
              size: contentSize
            })
          }); // console.log('-=-=-=-=- case 2');
          // console.log(metadata);
        } // console.log('-=-=-=-=-');
        // console.log(metadata);

      }
    }

    return metadata;
  }, [metadata, mass, fillerType]); // return metadata
}

var ItemType;

(function (ItemType) {
  ItemType[ItemType["COLUMN"] = 0] = "COLUMN";
  ItemType[ItemType["ROW"] = 1] = "ROW"; // COLUMN = 'column',
  // ROW = 'row',
})(ItemType || (ItemType = {}));

var ScrollDirection;

(function (ScrollDirection) {
  ScrollDirection[ScrollDirection["FORWARD"] = 0] = "FORWARD";
  ScrollDirection[ScrollDirection["BACKWARD"] = 1] = "BACKWARD"; // FORWARD = 'forward',
  // BACKWARD = 'backward',
})(ScrollDirection || (ScrollDirection = {}));

function useRangeHelper(_a) {
  var fixedTopCount = _a.fixedTopCount,
      fixedBottomCount = _a.fixedBottomCount,
      fixedLeftCount = _a.fixedLeftCount,
      fixedRightCount = _a.fixedRightCount,
      contentWidth = _a.contentWidth,
      contentHeight = _a.contentHeight,
      getItemCount = _a.getItemCount,
      getItemMetadata = _a.getItemMetadata,
      getSize = _a.getSize;
  var helper2 = useMemo(function () {
    // console.log({
    //   fixedTopCount,
    //   fixedBottomCount,
    //   fixedLeftCount,
    //   fixedRightCount,
    //   contentWidth,
    //   contentHeight,
    //   getItemCount,
    //   getItemMetadata,
    //   getSize,
    // }
    // )
    // binary search
    var findNearestItem = function (itemType, offset) {
      var low = 0;
      var high = getItemCount(itemType) - 1; // if (itemType === ItemType.COLUMN) {
      //   console.log({
      //     low,
      //     high,
      //   });
      // }

      while (low <= high) {
        var middle = low + Math.floor((high - low) / 2);
        var currentOffset = getItemMetadata(itemType, middle).offset_;

        if (currentOffset === offset) {
          return middle;
        } else if (currentOffset < offset) {
          low = middle + 1;
        } else if (currentOffset > offset) {
          high = middle - 1;
        }
      } // console.log(low);


      return low > 0 ? low - 1 : 0;
    };

    var getStartIndex = function (itemType, offset) {
      var itemIndex = itemType === ItemType.ROW ? fixedTopCount : fixedLeftCount;
      var itemMetadata = getItemMetadata(itemType, itemIndex); // if (itemType === ItemType.COLUMN) {
      //   console.log(itemIndex, offset, itemMetadata.offset);
      // }

      return findNearestItem(itemType, offset + itemMetadata.offset);
    };

    var getStopIndex = function (itemType, startIndex, offset) {
      var maxOffset = (itemType === ItemType.ROW ? contentHeight : contentWidth) + offset;
      var postfixCount = itemType === ItemType.ROW ? fixedBottomCount : fixedRightCount;

      if (postfixCount > 0) {
        // maxOffset -= getSize(itemType, postfixCount * -1);
        maxOffset -= getSize(itemType, postfixCount * -1);
      }

      var itemMetadata = getItemMetadata(itemType, startIndex);
      var currOffset = itemMetadata.offset + itemMetadata.size;
      var stopIndex = startIndex;
      var itemCount = getItemCount(itemType);

      while (stopIndex < itemCount - 1 && currOffset < maxOffset) {
        stopIndex += 1;
        currOffset += getItemMetadata(itemType, stopIndex).size;
      } // if (ItemType.ROW === itemType) {
      //   console.log('%c-=-=-=-=-=-=-=-=-=-', 'background:red;color:#fff');
      //   console.log({
      //     startIndex,
      //     stopIndex,
      //     postfixCount,
      //     _currOffset,
      //     maxOffset,
      //     contentHeight,
      //   });
      // }


      return stopIndex;
    }; // const getOverscanCount = (
    //   direction: string,
    //   startIndex: number,
    //   stopIndex: number,
    //   minIndex: number,
    //   maxIndex: number,
    //   _overscanCount: number,
    // ) => {
    //   const overscanBackward = direction === 'backward' ? Math.max(1, _overscanCount) : 1;
    //   const overscanForward = direction === 'forward' ? Math.max(1, _overscanCount) : 1;
    //   return {
    //     overscanStartIndex: Math.max(0, minIndex, startIndex - overscanBackward),
    //     overscanStopIndex: Math.max(0, Math.min(maxIndex, stopIndex + overscanForward)),
    //   };
    // };


    return {
      getStartIndex: getStartIndex,
      getStopIndex: getStopIndex
    };
  }, [fixedTopCount, fixedBottomCount, fixedLeftCount, fixedRightCount, contentWidth, contentHeight, getItemCount, getItemMetadata, getSize]);
  return helper2;
}

function useDefaultProps(props) {
  return useMemo(function () {
    return {
      fixedTopCount: ~~props.fixedTopCount,
      fixedLeftCount: ~~props.fixedLeftCount,
      fixedRightCount: ~~props.fixedRightCount,
      fixedBottomCount: ~~props.fixedBottomCount,
      minVisibleScrollViewWidth: ~~props.minVisibleScrollViewWidth,
      minVisibleScrollViewHeight: ~~props.minVisibleScrollViewHeight,
      overscanCount: ~~props.overscanCount
    };
  }, [props.fixedTopCount, props.fixedLeftCount, props.fixedRightCount, props.fixedBottomCount, props.minVisibleScrollViewWidth, props.minVisibleScrollViewHeight, props.overscanCount]);
}

function useHelpers(props) {
  var columnCount = props.columnCount,
      columnWidth = props.columnWidth,
      rowCount = props.rowCount,
      rowHeight = props.rowHeight,
      _innerWidth = props.innerWidth,
      _innerHeight = props.innerHeight,
      scrollbarWidth = props.scrollbarWidth,
      scrollbarHeight = props.scrollbarHeight,
      fillerColumn = props.fillerColumn,
      fillerRow = props.fillerRow,
      _a = props.maxHeight,
      maxHeight = _a === void 0 ? null : _a,
      overscanDirection = props.overscanDirection;

  var _b = useDefaultProps(props),
      fixedTopCount = _b.fixedTopCount,
      fixedLeftCount = _b.fixedLeftCount,
      fixedRightCount = _b.fixedRightCount,
      fixedBottomCount = _b.fixedBottomCount,
      minVisibleScrollViewWidth = _b.minVisibleScrollViewWidth,
      minVisibleScrollViewHeight = _b.minVisibleScrollViewHeight,
      overscanCount = _b.overscanCount;

  var _columnMetadata = useMetadata(columnCount, columnWidth, fixedLeftCount, fixedRightCount);

  var _rowMetadata = useMetadata(rowCount, rowHeight, fixedTopCount, fixedBottomCount);

  var scrollWidth = _columnMetadata.total.size;
  var scrollHeight = _rowMetadata.total.size;

  var _c = useMemo(function () {
    var innerWidth = _innerWidth;
    var innerHeight = _innerHeight;
    var contentWidth = innerWidth; // console.log({ contentHeight, innerWidth });

    var contentHeight;

    if (maxHeight) {
      contentHeight = Math.min(maxHeight, scrollHeight + scrollbarHeight);
    } else {
      contentHeight = innerHeight;
    } // if (con
    // scroll


    var scrollbarX = contentWidth < scrollWidth;

    var _contentHeight = contentHeight - (scrollbarX ? scrollbarHeight : 0);

    var scrollbarY = _contentHeight < scrollHeight;

    if (!scrollbarX && scrollbarY) {
      var _contentWidth = contentWidth - (scrollbarY ? scrollbarWidth : 0);

      scrollbarX = _contentWidth < scrollWidth;
    }

    if (scrollbarX) {
      contentHeight -= scrollbarHeight;
    }

    if (scrollbarY) {
      contentWidth -= scrollbarWidth;
    } // contentHeight -= scrollbarX ? scrollbarHeight : 0;
    // console.log({ scrollbarX, scrollbarY });
    // if (scrollHeight < contentHeight) {
    //   contentHeight = scrollHeight;
    // }


    if (fillerColumn === 'shrink' && scrollWidth < contentWidth) {
      contentWidth = scrollWidth;
    }

    innerWidth = contentWidth + (scrollbarY ? scrollbarWidth : 0);

    if (fillerRow === 'shrink' && scrollHeight < contentHeight) {
      contentHeight = scrollHeight;
    } // else {
    //   // console.log({ innerHeight, scrollHeight })
    //   // innerHeight = scrollHeight + (scrollbarX ? scrollbarHeight : 0);
    // }


    innerHeight = contentHeight + (scrollbarX ? scrollbarHeight : 0); // console.log(innerHeight);

    if (!scrollbarX && !scrollbarY && maxHeight && innerHeight > scrollHeight) {
      innerHeight = scrollHeight;
      contentHeight = scrollHeight;
    }

    return [contentWidth, contentHeight, innerWidth, innerHeight];
  }, [_innerWidth, _innerHeight, scrollWidth, scrollHeight, scrollbarWidth, scrollbarHeight, fillerColumn, fillerRow, maxHeight]),
      clientWidth = _c[0],
      clientHeight = _c[1],
      innerWidth = _c[2],
      innerHeight = _c[3];

  var columnMetadata = useMetadataFixed(_columnMetadata, clientWidth, fillerColumn, minVisibleScrollViewWidth);
  var rowMetadata = useMetadataFixed(_rowMetadata, clientHeight, fillerRow, minVisibleScrollViewHeight); // minVisibleScrollViewWidth,
  // minVisibleScrollViewHeight,
  // let columnMetadata = _columnMetadata;
  // let rowMetadata = useMetadataFixed(_rowMetadata, clientHeight, false);
  // let rowMetadata = _rowMetadata

  var _d = useMemo(function () {
    var columnCount = columnMetadata.total.count;
    var rowCount = rowMetadata.total.count;

    var getItemMetadata = function (itemType, itemIndex) {
      return (itemType === ItemType.COLUMN ? columnMetadata : rowMetadata).meta[itemIndex];
    };

    var getItemCount = function (itemType) {
      return itemType === ItemType.ROW ? rowCount : columnCount;
    };

    var getSize = function (itemType, count) {
      var dict = (itemType === ItemType.COLUMN ? columnMetadata : rowMetadata).meta;
      var itemCount = itemType === ItemType.COLUMN ? columnCount : rowCount;
      var size = 0;

      if (count > 0) {
        for (var itemIndex = 0; itemIndex < count; itemIndex += 1) {
          size += dict[itemIndex].size;
        }
      } else {
        for (var itemIndex = itemCount - 1; itemIndex >= itemCount + count; itemIndex -= 1) {
          size += dict[itemIndex].size;
        }
      }

      return size;
    };

    return {
      getItemMetadata: getItemMetadata,
      getItemCount: getItemCount,
      getSize: getSize
    };
  }, [columnMetadata, rowMetadata]),
      getItemMetadata = _d.getItemMetadata,
      getItemCount = _d.getItemCount,
      getSize = _d.getSize;

  var _e = useRangeHelper({
    // @ts-ignore
    fixedTopCount: rowMetadata.pre.count,
    // @ts-ignore
    fixedBottomCount: rowMetadata.post.count,
    // @ts-ignore
    fixedLeftCount: columnMetadata.pre.count,
    // @ts-ignore
    fixedRightCount: columnMetadata.post.count,
    // @ts-ignore
    contentWidth: columnMetadata.contentSize || clientWidth,
    // @ts-ignore
    contentHeight: rowMetadata.contentSize || clientHeight,
    getItemCount: getItemCount,
    getItemMetadata: getItemMetadata,
    getSize: getSize
  }),
      getStartIndex = _e.getStartIndex,
      getStopIndex = _e.getStopIndex; // function getRange
  // const overscanCount = 2;


  var _overscanCount = typeof overscanCount === 'number' ? overscanCount : 2;

  var _overscanForward = overscanDirection == 'forward';

  var getRange = useMemo(function () {
    return function (itemType, offset, scrollDirection) {
      var visibleStartIndex = getStartIndex(itemType, offset);
      var visibleStopIndex = getStopIndex(itemType, visibleStartIndex, offset);
      var overscanStartIndex = visibleStartIndex - (_overscanForward && scrollDirection === ScrollDirection.FORWARD ? 0 : _overscanCount);
      var overscanStopIndex = visibleStopIndex + (_overscanForward && scrollDirection !== ScrollDirection.FORWARD ? 0 : _overscanCount);
      return [overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex];
    };
  }, [getStartIndex, getStopIndex, _overscanCount, _overscanForward]);
  return {
    getItemMetadata: getItemMetadata,
    // getItemCount,
    // getSize,
    columnMetadata: columnMetadata,
    rowMetadata: rowMetadata,
    scrollWidth: scrollWidth,
    scrollHeight: scrollHeight,
    clientWidth: clientWidth,
    clientHeight: clientHeight,
    innerWidth: innerWidth,
    innerHeight: innerHeight,
    // @ts-ignore
    fixedTopCount: rowMetadata.pre.count,
    // @ts-ignore
    fixedBottomCount: rowMetadata.post.count,
    // @ts-ignore
    fixedLeftCount: columnMetadata.pre.count,
    // @ts-ignore
    fixedRightCount: columnMetadata.post.count,
    //     getStartIndex,
    // getStopIndex,
    getRange: getRange
  };
}

function useCachedItem(props) {
  var getItemMetadata = props.getItemMetadata;
  var columnCount = props.columnCount,
      columnWidth = props.columnWidth,
      rowCount = props.rowCount,
      rowHeight = props.rowHeight,
      classNames = props.classNames;

  var getItemStyle = function (rowIndex, columnIndex) {
    var row = getItemMetadata(ItemType.ROW, rowIndex);
    var column = getItemMetadata(ItemType.COLUMN, columnIndex);
    var style = {
      position: 'absolute',
      top: row.offset,
      height: row.size,
      left: column.offset,
      width: column.size
    };

    if (row.filler || column.filler) {
      // @ts-ignore
      style.overflow = 'hidden';
    }

    return {
      isFiller: column.filler || row.filler,
      rowIndex: row.filler ? -1 : rowIndex,
      columnIndex: column.filler ? -1 : columnIndex,
      style: style
    };
  };

  var cached__tmp = useRef({});
  var cached = useMemo(function () {
    cached__tmp.current = {}; // console.log('%c CACHE CLEARED!!!', 'background:yellow');

    return cached__tmp;
  }, [columnCount, columnWidth, rowCount, rowHeight, props.children, getItemMetadata]);
  var children = props.children;
  var getItemContent = useMemo(function () {
    if (typeof children === 'function') {
      return function (rowIndex, columnIndex, key, className, style, isFiller) {
        // @ts-ignore
        return createElement(children, {
          columnIndex: columnIndex,
          rowIndex: rowIndex,
          className: className,
          key: key,
          style: style,
          isFiller: isFiller
        });
      };
    }

    return function () {
      return null;
    };
  }, [children]); // const getClassName = (rowIndex, colIndex)

  var getCachedStyle = useMemo(function () {
    return function (rowIndex, colIndex, rowTypes, colTypes) {
      var key = rowIndex + '_' + colIndex;

      if (!cached.current[key]) {
        var _a = getItemStyle(rowIndex, colIndex),
            style = _a.style,
            isFiller = _a.isFiller,
            _rowIndex = _a.rowIndex,
            _colIndex = _a.columnIndex;

        var key_1 = rowIndex + '_' + colIndex;

        var className = __spreadArrays([classNames.CELL], rowTypes.map(function (e) {
          return classNames["ROW_" + e];
        }), colTypes.map(function (e) {
          return classNames["COL_" + e];
        }), [rowIndex % 2 == 0 ? classNames.ROW_EVEN : classNames.ROW_ODD, colIndex % 2 == 0 ? classNames.COL_EVEN : classNames.COL_ODD]).join(' ');

        cached.current[key_1] = {
          className: className,
          content: getItemContent(_rowIndex, _colIndex, key_1, className, style, isFiller),
          style: style
        };
      }

      return cached.current[key];
    };
  }, [cached.current, getItemContent, getItemMetadata, classNames]);
  return getCachedStyle;
}

var CLASSNAMES = {
  CONTAINER: 'grid-container',
  CELL: 'cell',
  COL_ODD: 'col-odd',
  COL_EVEN: 'col-even',
  COL_FIRST: 'col-first',
  COL_LAST: 'col-last',
  // ROW_ODD: 'row-odd',
  ROW_ODD: 'row-odd',
  ROW_EVEN: 'row-even',
  ROW_FIRST: 'row-first',
  ROW_LAST: 'row-last',
  SECTION: 'section',
  SECTION_TOP: 'section-top',
  SECTION_LEFT: 'section-left',
  SECTION_RIGHT: 'section-right',
  SECTION_BOTTOM: 'section-bottom',
  SECTION_CENTER: 'section-center',
  SECTION_CENTER_V: 'section-center-v',
  SECTION_CENTER_H: 'section-center-h',
  GUIDELINE: 'guideline',
  GUIDELINE_TOP: 'guideline-top',
  GUIDELINE_LEFT: 'guideline-left',
  GUIDELINE_RIGHT: 'guideline-right',
  GUIDELINE_BOTTOM: 'guideline-bottom',
  SCROLL_TOP: 'scroll-top',
  SCROLL_LEFT: 'scroll-left',
  SCROLL_RIGHT: 'scroll-right',
  SCROLL_BOTTOM: 'scroll-bottom',
  IS_SCROLLING: 'is-scrolling',
  IS_NOT_SCROLLING: 'is-not-scrolling'
};

function useClassNames(classNames) {
  var hash = useMemo(function () {
    return JSON.stringify(classNames);
  }, [classNames]);
  return useMemo(function () {
    return Object.keys(classNames || {}).reduce(function (accum, key) {
      var _a;

      return __assign(__assign({}, accum), (_a = {}, _a[key] = classNames[key], _a));
    }, __assign({}, CLASSNAMES)); // return JSON.stringify(classNames);
  }, [hash]);
}

function useGuidelines(rowMetadata, columnMetadata, clientWidth, clientHeight, classNames) {
  return useMemo(function () {
    var top = rowMetadata.pre.count && rowMetadata.pre.size;
    var left = columnMetadata.pre.count && columnMetadata.pre.size;
    var bottom = rowMetadata.post.count && rowMetadata.post.size;
    var right = columnMetadata.post.count && columnMetadata.post.size;
    var lines = [{
      className: classNames.GUIDELINE + " " + classNames.GUIDELINE_TOP,
      style: {
        width: clientWidth,
        top: top,
        left: 0
      }
    }, {
      className: classNames.GUIDELINE + " " + classNames.GUIDELINE_BOTTOM,
      style: {
        width: clientWidth,
        bottom: bottom,
        left: 0
      }
    }, {
      className: classNames.GUIDELINE + " " + classNames.GUIDELINE_LEFT,
      style: {
        height: clientHeight,
        top: 0,
        left: left
      }
    }, {
      className: classNames.GUIDELINE + " " + classNames.GUIDELINE_RIGHT,
      style: {
        height: clientHeight,
        top: 0,
        right: right
      }
    }].filter(function (e) {
      return e;
    });
    return lines;
  }, [rowMetadata, columnMetadata, clientWidth, clientHeight]);
}

function useHandle(callback) {
  var handle = useRef();
  handle.current = callback;
  return function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    if (typeof handle.current === 'function') {
      handle.current.apply(handle, args);
    }
  };
}

var noop = function () {
  return undefined;
};

function pixelToNumber(value) {
  var pattern = /^([0-9]+)px$/;

  if (typeof value === 'string' && value.match(pattern)) {
    return parseFloat(value.replace(pattern, '$1'));
  }

  return value;
}

function getComputedStyle(target, attributes) {
  var _a = target || {},
      _b = _a.offsetWidth,
      offsetWidth = _b === void 0 ? 0 : _b,
      _c = _a.offsetHeight,
      offsetHeight = _c === void 0 ? 0 : _c,
      _d = _a.clientWidth,
      clientWidth = _d === void 0 ? 0 : _d,
      _e = _a.clientHeight,
      clientHeight = _e === void 0 ? 0 : _e;

  var computed = target && attributes.length > 0 ? window.getComputedStyle(target) : {};
  return attributes.reduce(function (accum, attribute) {
    var _a;

    return __assign(__assign({}, accum), (_a = {}, _a[attribute] = pixelToNumber(computed[attribute]), _a));
  }, {
    offsetWidth: offsetWidth,
    offsetHeight: offsetHeight,
    clientWidth: clientWidth,
    clientHeight: clientHeight
  });
}

function useTarget(target) {
  var signature = target instanceof HTMLElement ? target : JSON.stringify(target);
  var dummy = useRef(null);
  return useMemo(function () {
    if (typeof target === 'function') {
      return {
        element: target,
        clear: noop
      };
    } else if (target instanceof HTMLElement) {
      return {
        element: function () {
          return target;
        },
        clear: noop
      };
    }

    dummy.current && document.body.removeChild(dummy.current);
    dummy.current = document.createElement('div');
    dummy.current.className = typeof target === 'string' ? css$1({
      position: 'absolute',
      top: -9999
    }) + ' ' + target : css$1(__assign({
      position: 'absolute',
      top: -9999
    }, target));
    document.body.appendChild(dummy.current);
    return {
      element: function () {
        return dummy.current;
      },
      clear: function () {
        dummy.current && document.body.removeChild(dummy.current);
        dummy.current = null;
      }
    };
  }, [signature]);
}

function useComputedStyle(target, attributes, watch) {
  if (watch === void 0) {
    watch = false;
  }

  var targetRef = useRef(null);
  targetRef.current = useTarget(target);

  var _a = useState(function () {
    return getComputedStyle(targetRef.current.element(), attributes);
  }),
      style = _a[0],
      setStyle = _a[1];

  var styleRef = useRef(null);
  styleRef.current = style;
  var requestId = useRef();
  useEffect(function () {
    if (style.offsetWidth > 0 && style.offsetHeight > 0 && watch === false) {
      targetRef.current.clear();
      return;
    }

    function sizeCheck() {
      requestId.current && cancelAnimationFrame(requestId.current);

      if (targetRef.current) {
        var computedStyle = getComputedStyle(targetRef.current.element(), attributes);

        if (computedStyle.offsetWidth > 0 && computedStyle.offsetHeight > 0 && JSON.stringify(styleRef.current) !== JSON.stringify(computedStyle)) {
          setStyle(computedStyle);

          if (watch === false) {
            targetRef.current.clear();
            return;
          }
        }
      }

      requestId.current = requestAnimationFrame(sizeCheck);
    }

    sizeCheck();
    return function () {
      requestId.current && cancelAnimationFrame(requestId.current);
      targetRef.current.clear();
    };
  }, [attributes.toString()]);
  return style;
}

var DEFAULT_HEIGHT = 400;

function useContainerStyle(objectStyles) {
  var objectStylesHash = useMemo(function () {
    return JSON.stringify(objectStyles);
  }, [objectStyles]);
  var className = useMemo(function () {
    return objectStyles && typeof objectStyles === 'object' ? css$1(objectStyles) : '';
  }, [objectStylesHash]);

  var _a = useComputedStyle(className, ['borderTopWidth', 'borderLeftWidth', 'borderRightWidth', 'borderBottomWidth']),
      borderTopWidth = _a.borderTopWidth,
      borderLeftWidth = _a.borderLeftWidth,
      borderRightWidth = _a.borderRightWidth,
      borderBottomWidth = _a.borderBottomWidth;

  return [className, borderTopWidth, borderLeftWidth, borderRightWidth, borderBottomWidth];
}

function useContainerInfo(_a) {
  var width = _a.width,
      height = _a.height,
      containerStyle = _a.containerStyle,
      theme = _a.theme,
      classNames = _a.classNames;
  var ref = useRef(null);

  var _b = useContainerStyle(containerStyle),
      containerClassName = _b[0],
      borderTop = _b[1],
      borderLeft = _b[2],
      borderRight = _b[3],
      borderBottom = _b[4];

  var clientWidth = useComputedStyle(function () {
    return ref.current && ref.current.parentElement;
  }, [], !width).clientWidth;

  var _c = useMemo(function () {
    var containerWidth = width || clientWidth;
    return [containerWidth, containerWidth - borderLeft - borderRight];
  }, [width, clientWidth, borderLeft, borderRight]),
      offsetWidth = _c[0],
      innerWidth = _c[1];

  var _d = useMemo(function () {
    var offsetHeight = typeof height === 'number' ? height : DEFAULT_HEIGHT;
    var innerHeight = offsetHeight - borderTop - borderBottom;
    return [offsetHeight, innerHeight];
  }, [height, borderTop, borderBottom]),
      offsetHeight = _d[0],
      innerHeight = _d[1];

  var className = useMemo(function () {
    return [classNames.CONTAINER, theme, containerClassName, css$1({
      height: offsetHeight
    })].filter(function (e) {
      return e;
    }).join(' ');
  }, [containerClassName, offsetHeight, classNames.CONTAINER || null]);
  return {
    ref: ref,
    className: className,
    offsetWidth: offsetWidth,
    // offsetHeight,
    innerWidth: innerWidth,
    innerHeight: innerHeight,
    borderTop: borderTop,
    borderLeft: borderLeft,
    borderRight: borderRight,
    borderBottom: borderBottom
  };
}

function useScrollbarSize(overflow) {
  var _a = useComputedStyle({
    width: 200,
    height: 200,
    overflow: 'scroll'
  }, []),
      offsetWidth = _a.offsetWidth,
      offsetHeight = _a.offsetHeight,
      clientWidth = _a.clientWidth,
      clientHeight = _a.clientHeight;

  if (overflow === false) {
    return [0, 0];
  }

  return [offsetWidth - clientWidth, offsetHeight - clientHeight];
}

function useScrollHelper(rowCount, columnCount, fixedBottomCount, fixedRightCount, getItemMetadata, misc) {
  var target = useRef(null);
  var state = useRef({
    isScrolling: false,
    position: null
  });
  var animejs = useRef();

  var _a = useMemo(function () {
    var begin = function (anim) {
      state.current.isScrolling = true;
      state.current.position = null;
      animejs.current = anim;
    };

    var update = function (anim) {
      // @ts-ignore
      anim.animations.reduce(function (accum, _a) {
        var _b;

        var property = _a.property,
            currentValue = _a.currentValue;
        return __assign(__assign({}, accum), (_b = {}, _b[property] = currentValue, _b));
      }, {});
    };

    var complete = function () {
      state.current.isScrolling = false;
      state.current.position = null;
      animejs.current = undefined;
    };

    var scrollTo = function (_a) {
      var x = _a.x,
          y = _a.y,
          _b = _a.easing,
          easing = _b === void 0 ? 'easeInCubic' : _b,
          _c = _a.duration,
          duration = _c === void 0 ? 200 : _c;

      if (!target.current || target.current.scrollTop === y && target.current.scrollLeft === x) {
        return false;
      }

      if (animejs.current) {
        animejs.current.pause();
        complete();
      }

      anime({
        targets: target.current,
        scrollLeft: x,
        scrollTop: y,
        easing: easing,
        duration: duration,
        begin: begin,
        update: update,
        complete: complete
      });
      return true;
    };

    var isScrolling = function () {
      return state.current.isScrolling;
    };

    var check = function (x, y) {
      if (state.current.position && animejs.current) {
        var _a = state.current.position,
            scrollTop = _a.scrollTop,
            scrollLeft = _a.scrollLeft;

        if (Math.abs(scrollTop - y) > 1 || Math.abs(scrollLeft - x) > 1) {
          animejs.current.pause();
          complete();
        }
      }
    };

    return [scrollTo, isScrolling, check];
  }, []),
      scrollTo = _a[0],
      isScrolling = _a[1],
      check = _a[2];

  var scrollToIndexFn = useRef();
  scrollToIndexFn.current = useMemo(function () {
    return function (_a) {
      var rowIndex = _a.rowIndex,
          columnIndex = _a.columnIndex,
          easing = _a.easing,
          duration = _a.duration;
      var x = typeof columnIndex === 'undefined' ? misc.current.scrollLeft : getItemMetadata(ItemType.COLUMN, Math.max(0, Math.min(columnIndex, columnCount - fixedRightCount - 1))).localOffset;
      var y = typeof rowIndex === 'undefined' ? misc.current.scrollTop : getItemMetadata(ItemType.ROW, Math.max(0, Math.min(rowIndex, rowCount - fixedBottomCount - 1))).localOffset;
      scrollTo({
        x: x,
        y: y,
        easing: easing,
        duration: duration
      });
    };
  }, [rowCount, columnCount, fixedBottomCount, fixedRightCount, getItemMetadata, misc]);

  var scrollToIndex = function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    return scrollToIndexFn.current && scrollToIndexFn.current.apply(scrollToIndexFn, args);
  };

  return {
    target: target,
    scrollTo: scrollTo,
    scrollToIndex: scrollToIndex,
    check: check,
    isScrolling: isScrolling
  };
}

function closestGridOffset(itemType, misc) {
  var sections = misc.sections,
      getItemMetadata = misc.getItemMetadata;
  var scrollDirection = itemType === ItemType.ROW ? misc.verticalScrollDirection : misc.horizontalScrollDirection;
  var clientSize = itemType === ItemType.ROW ? misc.clientHeight : misc.clientWidth;
  var scrollOffset = itemType === ItemType.ROW ? misc.scrollTop : misc.scrollLeft;
  var scrollSize = itemType === ItemType.ROW ? misc.scrollHeight : misc.scrollWidth;
  var itemCount = itemType === ItemType.ROW ? misc.rowCount : misc.columnCount;
  var postNm = itemType === ItemType.ROW ? 'bottom' : 'right';
  var typeNm = itemType === ItemType.ROW ? 'height' : 'width';
  var postFixedCount = (itemType === ItemType.ROW ? misc.fixedBottomCount : misc.fixedRightCount) || 0;
  var startIndex = itemType === ItemType.ROW ? misc.visibleRowStartIndex : misc.visibleColumnStartIndex;
  var stopIndex = itemType === ItemType.ROW ? misc.visibleRowStopIndex : misc.visibleColumnStopIndex;
  var startOffset = getItemMetadata(itemType, startIndex).localOffset;

  if (startOffset < scrollOffset) {
    if (scrollDirection === ScrollDirection.FORWARD && stopIndex === itemCount - postFixedCount - 1) {
      var efs = clientSize;
      var bottom = sections.filter(function (e) {
        return e.key === postNm;
      })[0];

      if (bottom) {
        efs = efs - bottom.style[typeNm];
      }

      var _a = getItemMetadata(itemType, stopIndex),
          size = _a.size,
          offset = _a.offset;

      if (offset + size / 2 < scrollOffset + efs) {
        return scrollSize - clientSize;
      }
    }

    var svc = getItemMetadata(itemType, startIndex); // console.log(svc);

    if (startOffset + svc.size / 2 < scrollOffset) {
      // console.log('case 1');
      return startOffset + svc.size;
    } else {
      // console.log('case 2');
      return startOffset;
    } // console.log(ranges.top, scrollTop);

  }

  return scrollOffset;
}

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css = ".WindowGrid-module_root__3L4h- {\n  position: absolute;\n  top: 0;\n  left: 0;\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  will-change: transform;\n}\n\n.WindowGrid-module_root__3L4h-.WindowGrid-module_overflowHidden__vMhA4 {\n  overflow: hidden;\n}\n\n.WindowGrid-module_root__3L4h- .WindowGrid-module_center__1QwnS,\n.WindowGrid-module_root__3L4h- .WindowGrid-module_sticky__3Zrox {\n  float: left;\n}\n\n.WindowGrid-module_root__3L4h- .WindowGrid-module_center__1QwnS > div,\n.WindowGrid-module_root__3L4h- .WindowGrid-module_sticky__3Zrox > div {\n  box-sizing: border-box;\n  overflow: hidden;\n}\n\n.WindowGrid-module_root__3L4h- .WindowGrid-module_sticky__3Zrox {\n  position: -webkit-sticky;\n  position: sticky;\n  width: 0;\n  z-index: 1;\n}\n\n.WindowGrid-module_guidelines__RIDtz {\n  position: absolute;\n  top: 0;\n  left: 0;\n  pointer-events: none;\n}\n\n.WindowGrid-module_guidelines__RIDtz > div {\n  position: absolute;\n  box-sizing: border-box;\n}\n\n.WindowGrid-module_center__1QwnS,\n.WindowGrid-module_sticky__3Zrox {\n  float: left;\n}\n\n.WindowGrid-module_sticky__3Zrox {\n  position: -webkit-sticky;\n  position: sticky;\n  width: 0;\n  z-index: 1;\n}\n";
var styles = {"root":"WindowGrid-module_root__3L4h-","overflowHidden":"WindowGrid-module_overflowHidden__vMhA4","center":"WindowGrid-module_center__1QwnS","sticky":"WindowGrid-module_sticky__3Zrox","guidelines":"WindowGrid-module_guidelines__RIDtz"};
styleInject(css);

function useItems(rowRange, colRange, getCachedStyle) {
  var rowStartIndex = rowRange[0],
      rowStopIndex = rowRange[1],
      minRowIndex = rowRange[2],
      maxRowIndex = rowRange[3];
  var colStartIndex = colRange[0],
      colStopIndex = colRange[1],
      minColIndex = colRange[2],
      maxColIndex = colRange[3];
  return useMemo(function () {
    // const
    var items = [];

    for (var rowIndex = rowStartIndex; rowIndex < rowStopIndex; rowIndex++) {
      var rowType = [];

      if (rowIndex === minRowIndex) {
        rowType.push('FIRST');
      }

      if (rowIndex === maxRowIndex - 1) {
        rowType.push('LAST');
      }

      for (var colIndex = colStartIndex; colIndex < colStopIndex; colIndex++) {
        var colType = [];

        if (colIndex === minColIndex) {
          colType.push('FIRST');
        }

        if (colIndex === maxColIndex - 1) {
          colType.push('LAST');
        }

        var _a = getCachedStyle(rowIndex, colIndex, rowType, colType),
            content = _a.content,
            style = _a.style;

        items.push(content); //   <div key={key} style={style} className={(rowIndex + colIndex) % 2 ? styles.odd : styles.even}>
        //     {content}
        //     {/* {rowIndex}, {colIndex} */}
        //   </div>,
        // );
      }
    }

    return items;
  }, [rowStartIndex, rowStopIndex, colStartIndex, colStopIndex, getCachedStyle]);
}

function useRange(rowMetadata, overscanRowStartIndex, overscanRowStopIndex, columnMetadata, overscanColumnStartIndex, overscanColumnStopIndex) {
  return useMemo(function () {
    return {
      top: __spreadArrays(rowMetadata.pre.range, rowMetadata.pre.range),
      bottom: __spreadArrays(rowMetadata.post.range, rowMetadata.post.range),
      left: __spreadArrays(columnMetadata.pre.range, columnMetadata.pre.range),
      right: __spreadArrays(columnMetadata.post.range, columnMetadata.post.range),
      middle_v: [Math.max(rowMetadata.mid.range[0], overscanRowStartIndex), Math.min(rowMetadata.mid.range[1], overscanRowStopIndex + 1), rowMetadata.pre.range[1], rowMetadata.post.range[0]],
      // middle_v_: [
      //   Math.min(rowMetadata.mid.range[0], overscanRowStartIndex),
      //   Math.max(rowMetadata.mid.range[1], overscanRowStopIndex + 1),
      // ],
      middle_h: [Math.max(columnMetadata.mid.range[0], overscanColumnStartIndex), Math.min(columnMetadata.mid.range[1], overscanColumnStopIndex + 1), columnMetadata.pre.range[1], columnMetadata.post.range[0]]
    };
  }, [rowMetadata, overscanRowStartIndex, overscanRowStopIndex, columnMetadata, overscanColumnStartIndex, overscanColumnStopIndex]);
}

function useSections(rowMetadata, columnMetadata, overscanRowStartIndex, overscanRowStopIndex, overscanColumnStartIndex, overscanColumnStopIndex, contentWidth, contentHeight, getCachedStyle, classNames) {
  var range = useRange(rowMetadata, overscanRowStartIndex, overscanRowStopIndex, columnMetadata, overscanColumnStartIndex, overscanColumnStopIndex);
  var sections = [{
    key: 'top',
    className: classNames.SECTION + " " + classNames.SECTION_TOP + " " + classNames.SECTION_CENTER_H + " " + styles.sticky,
    style: {
      top: 0
    },
    items: useItems(range.top, range.middle_h, getCachedStyle)
  }, {
    key: 'left',
    className: classNames.SECTION + " " + classNames.SECTION_CENTER_V + " " + classNames.SECTION_LEFT + " " + styles.sticky,
    style: {
      left: 0
    },
    items: useItems(range.middle_v, range.left, getCachedStyle)
  }, {
    key: 'right',
    className: classNames.SECTION + " " + classNames.SECTION_CENTER_V + " " + classNames.SECTION_RIGHT + " " + styles.sticky,
    style: {
      left: contentWidth - columnMetadata.post.size,
      width: columnMetadata.post.size
    },
    items: useItems(range.middle_v, range.right, getCachedStyle)
  }, {
    key: 'top-left',
    className: classNames.SECTION + " " + classNames.SECTION_TOP + " " + classNames.SECTION_LEFT + " " + styles.sticky,
    style: {
      top: 0,
      left: 0
    },
    items: useItems(range.top, range.left, getCachedStyle)
  }, {
    key: 'top-right',
    className: classNames.SECTION + " " + classNames.SECTION_TOP + " " + classNames.SECTION_RIGHT + " " + styles.sticky,
    style: {
      top: 0,
      left: contentWidth - columnMetadata.post.size,
      width: columnMetadata.post.size
    },
    items: useItems(range.top, range.right, getCachedStyle)
  }, {
    key: 'bottom',
    className: classNames.SECTION + " " + classNames.SECTION_BOTTOM + " " + classNames.SECTION_CENTER_H + " " + styles.sticky,
    style: {
      top: contentHeight - rowMetadata.post.size,
      height: rowMetadata.post.size
    },
    items: useItems(range.bottom, range.middle_h, getCachedStyle)
  }, {
    key: 'bottom-left',
    className: classNames.SECTION + " " + classNames.SECTION_BOTTOM + " " + classNames.SECTION_LEFT + " " + styles.sticky,
    style: {
      top: contentHeight - rowMetadata.post.size,
      left: 0,
      height: rowMetadata.post.size
    },
    items: useItems(range.bottom, range.left, getCachedStyle)
  }, {
    key: 'bottom-right',
    className: classNames.SECTION + " " + classNames.SECTION_BOTTOM + " " + classNames.SECTION_RIGHT + " " + styles.sticky,
    style: {
      top: contentHeight - rowMetadata.post.size,
      left: contentWidth - columnMetadata.post.size,
      width: columnMetadata.post.size,
      height: rowMetadata.post.size
    },
    items: useItems(range.bottom, range.right, getCachedStyle)
  }].filter(function (e) {
    return e.items.length > 0;
  }).map(function (e) {
    return __assign({}, e);
  });
  return {
    center: {
      key: 'middle',
      className: styles.inner,
      style: {
        width: columnMetadata.total.size,
        height: rowMetadata.total.size
      },
      items: useItems(range.middle_v, range.middle_h, getCachedStyle)
    },
    sections: sections
  };
}

function defaultTheme(_) {
  var _a, _b, _c, _d, _e;

  return css$1((_a = {
    position: 'relative',
    boxSizing: 'border-box'
  }, _a[_.CELL] = {
    boxSizing: 'border-box',
    overflow: 'hidden',
    background: '#fff'
  }, _a[_.GUIDELINE_TOP] = {
    height: 5,
    background: 'linear-gradient(to bottom, rgba(0, 0, 0, 0.1) 0%, rgba(0, 0, 0, 0) 100%)'
  }, _a[_.GUIDELINE_BOTTOM] = {
    height: 5,
    background: 'linear-gradient(to top, rgba(0, 0, 0, 0.1) 0%, rgba(0, 0, 0, 0) 100%)'
  }, _a[_.GUIDELINE_LEFT] = {
    width: 5,
    background: 'linear-gradient(to right, rgba(0, 0, 0, 0.1) 0%, rgba(0, 0, 0, 0) 100%)'
  }, _a[_.GUIDELINE_RIGHT] = {
    width: 5,
    background: 'linear-gradient(to left, rgba(0, 0, 0, 0.1) 0%, rgba(0, 0, 0, 0) 100%)'
  }, _a[_.SCROLL_TOP] = (_b = {}, _b[_.GUIDELINE_TOP] = {
    opacity: 0
  }, _b), _a[_.SCROLL_BOTTOM] = (_c = {}, _c[_.GUIDELINE_BOTTOM] = {
    opacity: 0
  }, _c), _a[_.SCROLL_LEFT] = (_d = {}, _d[_.GUIDELINE_LEFT] = {
    opacity: 0
  }, _d), _a[_.SCROLL_RIGHT] = (_e = {}, _e[_.GUIDELINE_RIGHT] = {
    opacity: 0
  }, _e), _a));
}

function useTheme(theme, classNames) {
  var dotClassNames = useMemo(function () {
    return Object.keys(classNames).reduce(function (accum, key) {
      var _a;

      return __assign(__assign({}, accum), (_a = {}, _a[key] = "." + classNames[key], _a));
    }, {});
  }, [classNames]);
  return useMemo(function () {
    return [defaultTheme(dotClassNames), theme && css$1(theme(dotClassNames))].filter(function (e) {
      return e;
    }).join(' ');
  }, [theme, dotClassNames]);
}

var FillerType;

(function (FillerType) {
  FillerType["NONE"] = "none";
  FillerType["APPEND"] = "append";
  FillerType["STRETCH"] = "stretch";
  FillerType["SHRINK"] = "shrink";
})(FillerType || (FillerType = {})); // const IS_SCROLLING_DEBOUNCE_INTERVAL = 150;


var IS_SCROLLING_DEBOUNCE_INTERVAL = 150;

var WindowGrid = function (props, ref) {
  var _a = useState({
    isScrolling: false,
    scrollTop: 0,
    scrollLeft: 0,
    verticalScrollDirection: ScrollDirection.FORWARD,
    horizontalScrollDirection: ScrollDirection.FORWARD
  }),
      _b = _a[0],
      isScrolling = _b.isScrolling,
      scrollTop = _b.scrollTop,
      scrollLeft = _b.scrollLeft,
      verticalScrollDirection = _b.verticalScrollDirection,
      horizontalScrollDirection = _b.horizontalScrollDirection,
      setScroll = _a[1];

  var overflow = props.overflow !== false;
  var onScroll = useHandle(props.onScroll);
  var onResize = useHandle(props.onResize);
  var onVisibleRangeChange = useHandle(props.onVisibleRangeChange);
  var classNames = useClassNames(props.classNames);
  var theme = useTheme(props.theme, classNames);
  var containerInfo = useContainerInfo(__assign(__assign({}, props), {
    theme: theme,
    classNames: classNames
  }));

  var _c = useScrollbarSize(overflow),
      scrollbarWidth = _c[0],
      scrollbarHeight = _c[1];

  var helpers = useHelpers(__assign(__assign({}, props), {
    innerWidth: containerInfo.innerWidth,
    innerHeight: containerInfo.innerHeight,
    scrollbarWidth: scrollbarWidth,
    scrollbarHeight: scrollbarHeight,
    overscanDirection: props.overscanDirection || 'forward'
  })); // console.log('helpers', helpers)

  var columnMetadata = helpers.columnMetadata,
      rowMetadata = helpers.rowMetadata,
      scrollWidth = helpers.scrollWidth,
      scrollHeight = helpers.scrollHeight,
      clientWidth = helpers.clientWidth,
      clientHeight = helpers.clientHeight,
      innerWidth = helpers.innerWidth,
      innerHeight = helpers.innerHeight;
  var getItemMetadata = helpers.getItemMetadata,
      getRange = helpers.getRange;
  var columnCount = props.columnCount,
      columnWidth = props.columnWidth,
      rowCount = props.rowCount,
      rowHeight = props.rowHeight;
  var misc = useRef();
  var scrollHelper = useScrollHelper(rowCount, columnCount, helpers.fixedBottomCount, helpers.fixedRightCount, getItemMetadata, misc);
  var timeoutID = useRef();

  var handleScroll = function (event) {
    timeoutID.current && clearTimeout(timeoutID.current);
    var _a = event.currentTarget,
        nextScrollTop = _a.scrollTop,
        nextScrollLeft = _a.scrollLeft;
    var scroll = {
      isScrolling: true,
      scrollTop: nextScrollTop,
      scrollLeft: nextScrollLeft,
      verticalScrollDirection: scrollTop > nextScrollTop ? ScrollDirection.BACKWARD : ScrollDirection.FORWARD,
      horizontalScrollDirection: scrollLeft > nextScrollLeft ? ScrollDirection.BACKWARD : ScrollDirection.FORWARD,
      rowStartIndex: misc.current.visibleRowStartIndex,
      rowStopIndex: misc.current.visibleRowStopIndex,
      columnStartIndex: misc.current.visibleColumnStartIndex,
      columnStopIndex: misc.current.visibleColumnStopIndex,
      eventTime: new Date().valueOf()
    };
    setScroll(scroll);
    onScroll(scroll);
    scrollHelper.check(nextScrollLeft, nextScrollTop);
    timeoutID.current = setTimeout(function () {
      var _scroll = __assign(__assign({}, scroll), {
        isScrolling: false
      });

      if (misc.current && props.scrollSnap && !scrollHelper.isScrolling() && scrollHelper.scrollTo({
        x: closestGridOffset(ItemType.COLUMN, misc.current),
        y: closestGridOffset(ItemType.ROW, misc.current)
      })) {
        _scroll = __assign(__assign({}, scroll), {
          isScrolling: true
        });
      }

      if (_scroll.isScrolling === false) {
        var _a = getRange(ItemType.ROW, _scroll.scrollTop, _scroll.verticalScrollDirection),
            visibleRowStartIndex_1 = _a[2],
            visibleRowStopIndex_1 = _a[3];

        var _b = getRange(ItemType.COLUMN, _scroll.scrollLeft, _scroll.horizontalScrollDirection),
            visibleColumnStartIndex_1 = _b[2],
            visibleColumnStopIndex_1 = _b[3];

        _scroll.rowStartIndex = visibleRowStartIndex_1;
        _scroll.rowStopIndex = visibleRowStopIndex_1;
        _scroll.columnStartIndex = visibleColumnStartIndex_1;
        _scroll.columnStopIndex = visibleColumnStopIndex_1;
      }

      setScroll(_scroll);
      onScroll(_scroll);
    }, IS_SCROLLING_DEBOUNCE_INTERVAL);
  };

  useEffect(function () {
    return function () {
      return timeoutID.current && clearTimeout(timeoutID.current);
    };
  }, []);

  var _d = getRange(ItemType.ROW, scrollTop, verticalScrollDirection),
      overscanRowStartIndex = _d[0],
      overscanRowStopIndex = _d[1],
      visibleRowStartIndex = _d[2],
      visibleRowStopIndex = _d[3];

  var _e = getRange(ItemType.COLUMN, scrollLeft, horizontalScrollDirection),
      overscanColumnStartIndex = _e[0],
      overscanColumnStopIndex = _e[1],
      visibleColumnStartIndex = _e[2],
      visibleColumnStopIndex = _e[3];

  var getCachedStyle = useCachedItem({
    getItemMetadata: getItemMetadata,
    columnCount: columnCount,
    columnWidth: columnWidth,
    rowCount: rowCount,
    rowHeight: rowHeight,
    children: props.children,
    classNames: classNames
  });

  var _f = useSections(rowMetadata, columnMetadata, overscanRowStartIndex, overscanRowStopIndex, overscanColumnStartIndex, overscanColumnStopIndex, clientWidth, clientHeight, getCachedStyle, classNames),
      center = _f.center,
      sections = _f.sections;

  misc.current = {
    clientHeight: clientHeight,
    clientWidth: clientWidth,
    columnCount: columnCount,
    fixedBottomCount: helpers.fixedBottomCount,
    fixedRightCount: helpers.fixedRightCount,
    getItemMetadata: getItemMetadata,
    horizontalScrollDirection: horizontalScrollDirection,
    rowCount: rowCount,
    scrollHeight: scrollHeight,
    scrollLeft: scrollLeft,
    scrollTop: scrollTop,
    scrollWidth: scrollWidth,
    sections: sections,
    verticalScrollDirection: verticalScrollDirection,
    visibleColumnStartIndex: visibleColumnStartIndex,
    visibleColumnStopIndex: visibleColumnStopIndex,
    visibleRowStartIndex: visibleRowStartIndex,
    visibleRowStopIndex: visibleRowStopIndex
  };
  useEffect(function () {
    onVisibleRangeChange({
      visibleColumnStartIndex: visibleColumnStartIndex,
      visibleColumnStopIndex: visibleColumnStopIndex,
      visibleRowStartIndex: visibleRowStartIndex,
      visibleRowStopIndex: visibleRowStopIndex
    });
  }, [visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex]);
  var guidelines = useGuidelines(rowMetadata, columnMetadata, clientWidth, clientHeight, classNames); // {"scrollTop":3417,"scrollLeft":0,"clientHeight":283,"scrollHeight":3700}
  // console.log(guidelines);
  // console.log(columnMetadata);
  //eturn null;

  var statusClassName = useMemo(function () {
    return [scrollTop === 0 && classNames.SCROLL_TOP, scrollLeft === 0 && classNames.SCROLL_LEFT, scrollTop >= scrollHeight - clientHeight && classNames.SCROLL_BOTTOM, scrollLeft >= scrollWidth - clientWidth && classNames.SCROLL_RIGHT, isScrolling ? classNames.IS_SCROLLING : classNames.IS_NOT_SCROLLING].filter(function (e) {
      return e;
    }).join(' '); // return classNames;
  }, [scrollTop, scrollLeft, clientHeight, scrollHeight, clientWidth, scrollWidth, isScrolling, classNames]);
  useEffect(function () {
    var rowIndex = props.defaultRowIndex,
        columnIndex = props.defaultColumnIndex;
    scrollHelper.scrollToIndex({
      rowIndex: rowIndex,
      columnIndex: columnIndex,
      duration: 0
    });
  }, [props.defaultRowIndex, props.defaultColumnIndex]);
  useImperativeHandle(ref, function () {
    return {
      scrollTo: scrollHelper.scrollToIndex
    };
  }, []);
  var offsetHeight = useMemo(function () {
    return innerHeight + containerInfo.borderTop + containerInfo.borderBottom;
  }, [innerHeight, containerInfo.borderTop, containerInfo.borderBottom]);
  useEffect(function () {
    if (clientWidth > 0) {
      onResize({
        offsetWidth: containerInfo.offsetWidth,
        // offsetHeight: containerInfo.offsetHeight,
        offsetHeight: offsetHeight,
        scrollWidth: scrollWidth,
        scrollHeight: scrollHeight,
        clientWidth: clientWidth,
        clientHeight: clientHeight,
        innerWidth: innerWidth,
        innerHeight: innerHeight,
        scrollbarWidth: scrollbarWidth,
        scrollbarHeight: scrollbarHeight,
        scrollbarY: innerWidth !== clientWidth,
        scrollbarX: innerHeight !== clientHeight
      });
    }
  }, [containerInfo.offsetWidth, // containerInfo.offsetHeight,
  offsetHeight, scrollWidth, scrollHeight, clientWidth, clientHeight, innerWidth, innerHeight, scrollbarWidth, scrollbarHeight]);
  return createElement("div", {
    ref: containerInfo.ref,
    className: containerInfo.className,
    style: {
      width: containerInfo.offsetWidth,
      height: offsetHeight
    }
  }, createElement("div", {
    className: statusClassName
  }, createElement("div", {
    ref: scrollHelper.target,
    style: {
      width: innerWidth,
      height: innerHeight
    },
    className: styles.root + " " + (overflow === false ? styles.overflowHidden : ''),
    onScroll: handleScroll
  }, createElement("div", {
    style: {
      width: scrollWidth,
      height: scrollHeight
    }
  }, sections.map(function (section) {
    return createElement("div", {
      key: section.key,
      className: section.className,
      style: section.style
    }, section.items);
  }), createElement("div", {
    className: classNames.SECTION + " " + classNames.SECTION_CENTER + " " + classNames.SECTION_CENTER_V + " " + classNames.SECTION_CENTER_H + " " + styles.center
  }, center.items))), props.guideline && createElement("div", {
    className: styles.guidelines,
    style: {
      width: clientWidth,
      height: clientHeight
    }
  }, guidelines.map(function (guideline, i) {
    return createElement("div", {
      key: i,
      className: guideline.className,
      style: guideline.style
    });
  }))));
};

var WindowGrid$1 = forwardRef(WindowGrid);

export { WindowGrid$1 as WindowGrid };
//# sourceMappingURL=react-window-grid.es.js.map
